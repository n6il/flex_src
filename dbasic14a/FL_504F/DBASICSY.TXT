 TTL BASIC RAM PATCHES FOR FLEX 1.4 - 5.0:2 - 4/10/83
 STTL COLOR COMPUTER BASIC UNDER FLEX
 PAG
 OPT PAG

*
* COPYRIGHT 1982 THOMAS S. SPEER
*
HOLD EQU $F5FE
HOLDB EQU $F600
SAVEB EQU $B800
SAVEND EQU $C000
OUTCH EQU $CD0F
OUTCH2 EQU $CD12

* STANDARD PRE-NAMED LABEL EQUATES

FPCNTR EQU $0003
BEGPRG EQU $0019
ENDPRG EQU $001B
STACK EQU $0021
MEMND2 EQU $0027
FPAC1 EQU $004F
FPAC2 EQU $005C
FPSGNC EQU $0062
DEVNUM EQU $006F
ZEROES EQU $008A
GETNXT EQU $009F
GETCUR EQU $00A5
CURCHR EQU $00A6
DCOPC EQU $00EA
DCDRV EQU $00EB
DCTRK EQU $00EC
DSEC EQU $00ED
DCBPT EQU $00EE
DCSTA EQU $00F0
NMIJ EQU $0109
NMIV EQU $010A
IRQV EQU $010D
VTABLD EQU $0134
CMDBUF EQU $02DD
CBFEND EQU $03D6
DSKRAM EQU $0600
DYNRAM EQU $0989
VCODEX EQU $813C
FCODEX EQU $8168
GETCHR EQU $A171
GETCH8 EQU $A176
CHROU1 EQU $A282
MOVE EQU $A59A
CLRSCR EQU $A928
OMERR EQU $AC44
ERRPRT EQU $AC46
SNERR EQU $B277
FCERR EQU $B44A
LIST EQU $B764
PSTRNG EQU $B99C
FPLDA1 EQU $BC14
FPSTO EQU $BC35
INT EQU $BCEE
DSKCTL EQU $FF40

* ASCII CODE EQUATES

NUL EQU $00
CR EQU $0D

* EXTERNAL LABEL EQUATES

L0001 EQU $0001
L0006 EQU $0006
L001D EQU $001D
L001F EQU $001F
L006C EQU $006C
L006D EQU $006D
L006E EQU $006E
INPFLG EQU $0070
L0072 EQU $0072
L008C EQU $008C
L009D EQU $009D
L00B0 EQU $00B0
L00B7 EQU $00B7
L00BA EQU $00BA
GRSCRN EQU $00BC
L00D3 EQU $00D3
L00D8 EQU $00D8
CURFCB EQU $00F1
L012D EQU $012D
L0132 EQU $0132
L0141 EQU $0141
L0146 EQU $0146
L015E EQU $015E
L01A0 EQU $01A0
L01A1 EQU $01A1
L0264 EQU $0264
L02DC EQU $02DC
L0680 EQU $0680
L06FF EQU $06FF
L0700 EQU $0700
L0712 EQU $0712
FATTBL EQU $0800
L084A EQU $084A
L0894 EQU $0894
L08DE EQU $08DE
FCBTAB EQU $0928
RBUFAD EQU $0948
FCBSAD EQU $094A
FILNAM EQU $094C
FILTYP EQU $0957
ASCFLG EQU $0958
DBITS EQU $0959
DRIVNO EQU $CC0C (WASN)
NFILES EQU $095B
L095C EQU $095C
L095D EQU $095D
L095E EQU $095E
L095F EQU $095F
DIRSEC EQU $0973
DIRADD EQU $0974
GRANUL EQU $0976
DIRSCF EQU $0977
DIRADF EQU $0978 
L097A EQU $097A  ?
RECLEN EQU $097C RECORD LENGTH FOR DIRECT ACCESS
TRKTBL EQU $097E TABLE OF CURRENT TRACKS
NMIUSE EQU $0982 NMI IN USE FLAG
NMEXIT EQU $0983 WHERE TO GO AFTER NMI
MTRTIM EQU $0985 MOTOR TIMEOUT COUNTER
MTRREG EQU $0986 LATCH OUTPUT (FF40) DATA
VERFLG EQU $D435 VERIFY FLAG
L0988 EQU $0988
L3404 EQU $3404
L80C0 EQU $80C0
L8273 EQU $8273
L8286 EQU $8286
L829C EQU $829C
L836C EQU $836C
L8603 EQU $8603
L8620 EQU $8620
L8649 EQU $8649
L86A0 EQU $86A0
GETSTR EQU $8748 RETURN X=STRING ADDR, B=LENGTH
L8846 EQU $8846
L88F0 EQU $88F0
L8955 EQU $8955
L8AC0 EQU $8AC0
L8C1B EQU $8C1B
L8CF1 EQU $8CF1
L8E90 EQU $8E90
L95AC EQU $95AC
L962E EQU $962E
L9650 EQU $9650
L96CB EQU $96CB
L96EC EQU $96EC
L975F EQU $975F
L9FB5 EQU $9FB5
LA0E2 EQU $A0E2
LA35F EQU $A35F
LA37C EQU $A37C
LA3ED EQU $A3ED
NOERR EQU $A3FB
LA406 EQU $A406
LA426 EQU $A426
LA429 EQU $A429
LA42D EQU $A42D
LA549 EQU $A549
PRSDEV  EQU $A5A2
PRSDV1 EQU $A5A5
LA5AE EQU $A5AE
LA5C7 EQU $A5C7
LA5DA EQU $A5DA
LA5E4 EQU $A5E4
LA603 EQU $A603
FMERR EQU $A616
AOERR EQU $A61C
DNERR EQU $A61F
LA7D1 EQU $A7D1
LA7E9 EQU $A7E9
LA951 EQU $A951
LA974 EQU $A974
LAC37 EQU $AC37
LAC60 EQU $AC60
LAC73 EQU $AC73
LAC7C EQU $AC7C
LACEF EQU $ACEF
LAD19 EQU $AD19
LAD21 EQU $AD21
LAD33 EQU $AD33
LAD9E EQU $AD9E
LADD4 EQU $ADD4
LAF9A EQU $AF9A
LAFA4 EQU $AFA4
LAFB1 EQU $AFB1
LB069 EQU $B069
LB143 EQU $B143
LB146 EQU $B146
LB148 EQU $B148
LB156 EQU $B156
LB166 EQU $B166
LB262 EQU $B262
COMCHK EQU $B26D
LB26F EQU $B26F
LB2CE EQU $B2CE
LB357 EQU $B357
LB3E6 EQU $B3E6
LB4F3 EQU $B4F3
LB4F4 EQU $B4F4
LB50F EQU $B50F
LB516 EQU $B516
LB654 EQU $B654
LB659 EQU $B659
LB69B EQU $B69B
LB6A4 EQU $B6A4
LB70B EQU $B70B
LB70E EQU $B70E
LB738 EQU $B738
LB73D EQU $B73D
LB958 EQU $B958
LB95C EQU $B95C
LB99F EQU $B99F
LB9A2 EQU $B9A2
LB9AC EQU $B9AC
LB9AF EQU $B9AF
LB9C5 EQU $B9C5
LBB91 EQU $BB91
LBC33 EQU $BC33
LBC5F EQU $BC5F
LBDCC EQU $BDCC
LBDD9 EQU $BDD9
ROM0 EQU $FF00
* FLEX EQUATES
* FMS EQU $D406
* RPTERR EQU $CD3F
SYSFCB EQU $C840 
MTROFF EQU $DE21
* PROGRAM EQUATES
 
FATSIZ EQU 74 SIZE AOF ONE FAT TABLE
* FCB OFFSETS

CHRCNT EQU 1
BAKFLG EQU 2 NON ZERO IF BYTE ALREADY READ 
BAKBYT EQU 3 ALREADY READ BYTE
FLXFCB EQU 4 START OF FLEX FCB
FCBDRV EQU FLXFCB+3
FCBSIZ EQU FLXFCB+320

  ORG $A055
 FCB $0D NUMBER OF SAM BYTES TO CLEAR

 ORG $A066
 FCB $20 BRANCH AROUND MEMSIZE CHANGE

 ORG $A084
 LDX #$7FFE SET END OF USER RAM
*LDX #$3FFE SET END OF USER RAM
 BRA $A093 SKIP MEMORY CHECK


 ORG $80E8
* FOLLOWING CODE OVERLAYS EXTENDED BASIC COPYRIGHT NOTICE
* RETURN TO FLEX FROM BASIC

FLEX LDB $FF01
    ANDB #$FE SHUTDOWN ALL IRQ'S
    STB $FF01
    LDB $FF03
    ANDB #$FE
    STB $FF03
    ORCC #$10
 LDX HOLD RSTORE I/O VECTORS
 STX OUTCH+1
 STX OUTCH2+1
 CLR $71 FORCE COMPLETE RESET
 LDX #HOLDB MOVE FLEX CODE BACK
 LDY #SAVEB
FLEX1 LDA ,X+
 STA ,Y+
 CMPY #SAVEND
 BNE FLEX1

 JSR [$D3F5] TINIT RELOCATE SCREEN
 JMP $CD03 WARMS WARM START FLEX


 ORG $C000
ZC000 RMB 4 ROM C000-C0A3
DSKCON FDB DSKCN1

 RMB $23
 FDB VCODXD
 RMB 4
 FDB FCODXD
 
 RMB $17
 FDB GETPUT

 RMB $13
 FDB NMID
 RMB 9
 FDB IRQD
 
 RMB $2A
 FDB FCBSIZ
 RMB $7
 FDB FCBSIZ
 RMB $5
 LEAX FCBSIZ,X
 STX FCBTAB+6
 CLR 0,X
 LDA #3 DEFAULT NO OF FILES
ZC0A6 RMB 5 ROM $C0A6-C0B2
 FDB FCBSIZ
 RMB 6
 BITA #$01
 BEQ LC0B3
 INC A
LC0B3
ZC0B3 RMB $0F ROM $C0B3 - $C0C1
ZC0C4 RMB 8 ROM $C0C4 -C0CB

 LDX #DBREST
 LDU #FATTBL+1
 LDB #DBRST9-DBREST
 JSR MOVE
 LDX #FATTBL+1
 STX <L0072
 JMP CLEAN


 ORG $C0F7
 FDB VERBSD,VCODED
 RMB 1
 FDB FUNCSD,FCODED,OPEND,ENT161
 FDB ENT164,OUTDCH,INPDCH,ENT16D
 FDB ENT170,CLSALL,CLOSED,L8E90
 FDB INPUTD,ENT17F,LRETRN,ENT185
 FDB EOFD,ENT18B,LRETRN,ERRPRD
 FDB RUND
DTANDX EQU *-1
DTANDY EQU *
 RMB $58
COPYRT FCC 'DBASIC VER 1.4 MODIFICATIONS',$D
 FCC       "FOR FHL FLEX  COPYRIGHT",$D
 FCC       "(C) 1982 BY THOMAS S. SPEER",0

CLEAN LDX #$C008 MAKE IT TOUGH ON PEOPLE
 CLRA
 CLRB
 STD 0,X++
 STD 0,X++
 LEAX 4,X
LOOP STA 0,X+
 CMPX #COPYRT
 BNE LOOP
 JMP $A0E2

* FOLLOWING CODE RESIDES IN LOW RAM (IN FORMER FATTBL)
* TO HANDLE THE RESET BUTTON. THE RESET BUTTON RESETS
* THE SAM CHIP, DISABLING HIGH RAM ANDS ENABLING ROM.

DBREST NOP
 STA $FFDF ENABLE RAM
 STA $FFDD 64K RAMS
 STA $FFDA THE REST WILL BE TAKEN CARE OF OK
 CLR MTRTIM
 JSR MTROFF TURN OFF DISK MOTORS
 JSR CLRFCB
 JMP L80C0
DBRST9 EQU *

 
 ORG $E600

VERBSD
ZC17F RMB $4E  ROM $C17F-$C299

 FCC 'FLE',$D8 REPLACE COPY VERB WITH FLEX
 RMB 10
VADDSD FDB DIR,DRIVE,FIELD,FILES
 FDB KILL,LOAD,LSET,MERGE
 FDB RENAME,RSET,SAVE,WRITE
 FDB VERIFY,UNLOAD,SNERR,SNERR
 FDB FLEX,DSKIN,DSKOUT
FUNCSD  RMB 19

FADDSD FDB CVN,FREE,LOC,LOF
 FDB MKN,SNERR
VCODED EQU * 
 RMB 4
 LDX #VADDSD
 RMB 7
 LBLS SNERR
 RMB 4
FCODED RMB 17 
 LDX #FADDSD
 RMB 3

ERRPRD  RMB 5
 JSR CLRFCB
 RMB 2
 JSR CLSALL
 RMB 4
 LBCS L88F0
 RMB 16
 LDX #ERRD-$36
 RMB 3
ERRD RMB 22 DISK ERROR CODES
BASTYP RMB 3 "BAS"
BLANKS RMB 3 "   "
DATTYP RMB 3 "DAT"
BINTYP RMB 3 "BIN"
GETPUT RTS 

IEERR 
ZC334 RMB 5 ROM $C334-$C338

OPEND 
ZC426 RMB 14 ROM $C426-$C480
 LBLE LA603 GO BACK IF NOT DISK
 RMB 9
 LDX #DATTYP DEFAULT IS .DAT
 JSR GETNAM PARSE DRIVE,NAME &TYPE
 RMB $18
 LBEQ FCERR
 RMB 5

OPENX RMB 2
 JSR GETFCB POINT TO FCB ACCORDING TO B REG.
 LBNE AOERR
 RMB 2
 BSR SETFCB
 LEAX FLXFCB,X POINT TO FLEX FCB
 NOP
 NOP FILL TO MATCH OLD CODE
 RMB 8

 BNE OPEN3
 LDA #1 OPEN FOR READ
 STA 0,X
 JSR FMS
 LBNE FMSERR BRANCH IF ERROR
 LDA ASCFLG
 COM A COMPLEMENT OF ASCII FLAG
 STA 59,X TO INDICATE BINARY OR NOT

OPEN2
ZC49B RMB 7  ROM $C49B - $C4A6

OPEN3 RMB 4
 BNE OPEN5

OPEN4 LDA #2
 STA 0,X OPEN FOR WRITE
 JSR FMS
 BNE OPEN4A
 LDA ASCFLG SACII OR BINARY
 COM A
 STA 59,X BINARY COMPRESSION FLAG
 BRA OPEN2
OPEN4A LDA 1,X
 CMPA #3 IS IT ALREADY EXISTING?
 BNE FMSERR
 PSHS X
 LBSR KILL2
 PULS X
 BRA OPEN4

OPEN5 LBRA FMERR

SETFCB
ZC50B RMB 2    ROM $C50B - C50C
 PSHS X
 LDB #FLXFCB+2

SETFC3
ZC50F RMB 5    ROM $C50F - $C513
 LEAX -2,X POINT TO BEGINNING OF FLEX FCB
 BRA SETFC4
SETFC2 PSHS X ENTRY FOR COPYING NAME TO ANY FCB
SETFC4 LDA <DCDRV
 STA 3,X
 LEAU 4,X 
ZC55E RMB 8 ROM $C55E - $C565
 PULS X,PC

INPDCH
ZC58F RMB 2 ROM $C58F - $C5A4
 LBLE L8CF1
 RMB 2
INPDC1 RMB 14

INPDC2 LDB BAKFLG,X
 BEQ INPDC3
 LDA BAKBYT,X PICK UP BYTE ALREADY READ
 CLR BAKFLG,X RESET FLAG
 PULS B,X,PC
INPDC3 LEAX FLXFCB,X
 CLR 0,X
 JSR FMS
 BEQ INPDC4
 LDA 1,X
 CMP A #8 EOF?
 BNE FMSERR
 COM INPFLG SET EOF
INPDC4 PULS B,X,PC


FMSERR LDB 1,X PICK UP ERROR BYTE
 JSR RPTERR PRINT FLEX ERROR MESSAGE
* NOP
* NOP NOP'S TO REPLACE JSR RPTERR
* NOP
 LEAX FETABL,PCR
 LDB B,X PICK UP BASIC ERROR MESSAGE
 JMP ERRPRT PRINT ERROR AND ABORT
FETABL FCB $28 IO 0 SHOULDN'T EVER HAPPEN
       FCB $28 IO 1 PROGRAM BUG IN PATCH
       FCB $24 AO 2 ALREADY OPEN
       FCB $42 AE 3 ALREADY EXISTS
       FCB $34 NE 4 FILE NOT FOUND
       FCB $40 FS 5 DIRECTORY ERROR
       FCB $38 DF 6 DIRECTORY FULL
       FCB $38 DF 7 DISK IS FULL
       FCB $2E IE 8 READ PAST END OF FILE
       FCB $28 IO 9 FILE READ ERROR
       FCB $28 IO 10 FILE WRITE ERROR
       FCB $3C WP 11 FILE OR DISK WRITE PROTECT
       FCB $3C WP 12 FILE IS PROTECTED
       FCB $28 IO 13 PROGRAM BUG
       FCB $40 FS 14 BAD DISK ADDRESS
       FCB $26 DN 15 DRIVE NUMBER ERR
       FCB $28 IO 16 DRIVE NOT READY
       FCB $28 IO 17 READ PROTECTED
       FCB $28 IO 18 SYSTEM FILE STATUS ERROR
       FCB $4A ER 19 DATA INDEX RANGE ERROR
       FCB $28 IO 20 CRASHO
       FCB $02 SN 21 BAD FILE NAME
       FCB $28 IO 22 ?
       FCB $40 FS 23 FRAGMENTED
       FCB $36 BR 24 BAD RECORD NUMBER
       FCB $40 FS 25 FILE DAMAGED
       FCB $02 SN 26 SYNTAX ERROR
       FCB $02 SN 27 NEVER HAPPEN
       FCB $02 SN 28 NEVER HAPPEN

KILL JSR GETNA0
ZC6C5  RMB 3  ROM $C6C5 - $C6C7
KILL2 LDX #SYSFCB USE SYSTEM FCB
 BSR SETFC2 PUT NAME INTO IT
 LDA #12  DELETE FILE
 STA 0,X
 JSR FMS
 BNE FMSERR BRANCH IF ERROR
 RTS

GTFCB2 
ZC714 RMB 5 ROM $C714 - $C724

* GETFCB RETURNS X POINTING TO THE FCB GIVEN BY B REG.
 
GETFCB RMB 12
  
* RANCHK OBTAIN DEVICE NUMER FROM COMMAND LINE
* MAKE SURE IT IS OPEN FOR RANDOM
* RETURNS X POINTING TO FCB
 
RANCHK
ZC7FE RMB 6 ROM $C7FE - $C87A
 LBLE FCERR
 JSR GETFCB
 RMB 2
 LBEQ NOERR
 RMB 2
 BEQ RETRN2

FMERRD RMB 3

ENT16D RMB 3

ENT170 RMB 4
 BLE RETRN2
 RMB 2
 JSR GTFCB2
 RMB 4
 LBEQ NOERR
 RMB 10

ENT161 BLE RETRN2 IN ROUTINE FOR PARSING DEV. #
 RMB 3
 LBHI DNERR
 RMB 2
 
ENT164  RMB 2
 BLE RETRN2
 RMB 6
 JSR GTFCB2
 LDB CHRCNT,X CHARACTER POSITION?
 RMB 7

ENT17F RMB 6
DSKCN1
RETRN2 EQU *
LRETRN EQU *
RETRN3 RTS

* EOF TEST FOR DISK
 
EOFD RMB 14
 LBLE LA5DA
 JSR GTFCB2
 RMB 6
 CMPB #$20
 BEQ EOFD8 OUTPUTS ARE ALWAYS AT EOF
* (THIS IS NOT CLEAR IN RS VERSION)
EOFD1 
 LDA FLXFCB+1,X LOOK AT ERROR STATUS BYTE
 CMPA #8 IS IT EOF?
 BEQ EOFD8
 LDA BAKFLG,X IF BYTE IS WAITING, NOT EOF
 BNE EOFD9
 LDU FLXFCB+64,X IF NOT LAST SECTOR,
 BNE EOFD9 NOT EOF
 LDB FLXFCB+34,X DATA INDEX POINTER
 CLRA POINTER IS NOT SIGNED
 LEAX FLXFCB+64,X BEGINNING OF SECTOR
EOFD2 TST D,X IF ANY NON ZERO BYTES LEFT,
 BNE EOFD9 NOT EOF
 INCB
 BNE EOFD2

EOFD8 LDB #$FF
 BRA LC884
EOFD9 CLRB
LC884
ZC884 RMB 3 ROM $C884 - $C9BD

GETNA0 LDX #BLANKS
GETNAM RMB 2 CLR 0,-S CLR SPOT ON STACK
 LDA DRIVNO SET DEFAULT DRIVE NO.
 RMB 5  
 LDD #$0008
GETNA1 RMB $9B

SAVE RMB 2
 LBEQ SAVEM
 RMB $1E

SAVE1 RMB 3

LOAD4 RMB 8
 JMP OPENX
SAVE3 RMB 4
 JSR OUTDC1
 RMB 4
 JSR OUTDC1
 RMB 2
 JSR OUTDC1
 RMB 4
 JSR OUTDC1
 RMB 7

GETBAS LDX #BASTYP
 JMP GETNAM

MERGE  RMB 5

RUND  RMB 2
 LBNE L829C
 RMB 4

LOAD  RMB 2 CMPA #'M
 LBEQ LOADM
 RMB $1E
LOAD3 CLR ASCFLG READ FIRST AS BINARY
 BSR LOAD4 OPEN FILE
 PSHS X SAVE FCB ADDRESS
 JSR INPU13 READ FIRST BYTE
 JSR INPU17 PUT IT BACK
 PULS X GET BACK FCB ADDRESS
 CMPA #$FF IF BYTE IS $FF 
 BEQ LOAD6 THEN ITS BINARY
 CLR FLXFCB+59,X IF NOT, READ AS ASCII

ZC9C5 RMB 8 ROM $C9C5 - $C9CF
LOAD5 RMB 3
LOAD6 LDA L095E
 LBNE FMERR
ZC9DA RMB 6 ROM $C9DA - $CA61
 JSR INPU13
 JSR INPU13
 RMB 2
 JSR INPU13
 RMB 11
LOAD7 JSR INPDC1
 RMB $36
 LBCS LAD9E
 RMB 3

ENT185 RMB 5

CLSALL RMB 16
CLOSED RMB 2 TST <DEVNUM
 LBLE L8286
 RMB 2 LEAS 2,S
CLOSE1 JSR GTFCB2
 RMB 2
CLOSE2 RMB 10
 LEAX FLXFCB,X
 LDA #4
 STA 0,X CLOSE FILE
 JSR FMS
 PULS A,PC
 
OUTDCH
ZCB4A RMB 2 ROM $CB4A - $CB6C
 LBLE L8273
 RMB 2
OUTDC1 RMB 14
 BEQ OUTDC5
 RMB 4
 CLR CHRCNT,X
OUTDC2 RMB 4
 INC CHRCNT,X
OUTDC3 
OUTDC4 LEAX FLXFCB,X
 CLR 0,X
 JSR FMS WRITE A CHARACTER
 LBNE FMSERR WATCH FOR ERRORS
OUTDC5 PULS A,B,X,PC

DIR JSR UNLOA3
 JSR LB958 OUTPUT A CARRIAGE RETURN
* READ DIRECTORY SECTOR
 LDX #SYSFCB
 LDA DCDRV
 STA 3,X
 LDA #6 OPEN DIRECTORY
 STA 0,X
 JSR FMS
 LBNE FMSERR
DIR1
ZCBEB  RMB 7  ROM $CBEB - $CBF1
 LDX #SYSFCB 
 LDA #7 GET INFO RECORD
 STA 0,X
 JSR FMS
 TFR CC,B
 LDA 1,X 
 CMPA #8 EOF?
 BEQ DIR9
 TFR B,CC
 LBNE FMSERR
 LEAX 4,X POINT TO NAME
 LDA 0,X LOOK AT FIRST BYTE OF ENTRY
 BLT DIR4 SKIP IF EMPTY
 BEQ DIR9 END IF 0
 LDB #8 PRINT 8 CHAR. POINTED TO BY X
DIR2 LDA 0,X+ GET A CHAR
 BNE DIR3
 LDA #'   CHANGE NULLS TO SPACES 
DIR3 JSR CHROU1
 DEC B
 BNE DIR2
 BSR SPCOUT 
 
ZCC02 RMB 5 ROM $CC02 - CC07

 BSR SPCOUT SPACE
 LDX #SYSFCB
 LDD 21,X SIZE IN SECTORS
 TST A
 BEQ DIR31
 JSR LBDCC PRINT NUMBER OF SECTORS
 BRA DIR32
DIR31 BSR DIR6
DIR32 BSR SPCOUT
 LDX #SYSFCB
 LDB 25,X
 BSR DIR7 PRINT MONTH
 LDB 26,X
 BSR DIR5 DAY
 LDB 27,X
 BSR DIR5 YEAR
 JSR LB958 CARRIAGE RETURN
DIR4 BRA DIR1
DIR5 LDA #'-
 JSR CHROU1 OUTPUT A SLASH
 BRA DIR7
DIR6 CMPB #100
 BCC DIR7
 BSR SPCOUT
DIR7 CMPB #10
 BCC DIR8
 BSR SPCOUT
DIR8 CLRA
 PSHS X
 JSR LBDCC OUTPUT A NUMBER
 PULS X

ZCC3D
DIR9 RMB 1 RTS ROM $CC3D - $CC43
CHRSPC RMB 3 JSR CHROU1 CHAR. OUT, THEN
SPCOUT RMB 3 JMP LB9AC OUTPUT A SPACE

INPUTD 
ZCC5B RMB $87 ROM $CC5B - $CD02
INPU13 RMB 4
 JSR GTFCB2 READ TOO FAR
 RMB 4
 LBNE IEERR
 RMB 11
INPU17 RMB 2
 JSR GTFCB2
 RMB 2
 
INPU18 STA BAKBYT,X BACKUP A BYTE
 COM BAKFLG,X
ZCD18 RMB 2 ROM $CD18 - $CD35

CVN RMB 5
 LBCS FCERR
 RMB 5

MKN RMB 14

LOC BSR LOC2
 LDD FLXFCB+32,X
LOC1
ZCD3A RMB 3 ROM $CD3A - $CD5C
LOC2 RMB 12
 LBLE FCERR
 JSR GTFCB2
 RMB 6
 LBEQ NOERR
 RMB 1
LOF RMB 2 BSR LOC2
 LDD FLXFCB+21,X
 TST FLXFCB+23,X
 BEQ LOC1 NO MORE PRCESSING IF SEQENTIAL
 SUBD #0002 SUBTRACT FILE SECTOR MAP
 BRA LOC1

FREE
ZCDC0 RMB 8 ROM $CDC0 - $CDC9
 LBHI DNERR
 LDX #SYSFCB POINT TO FCB
 STB 3,X SET DRIVE
 LDB #16 OPEN SIR
 STB 0,X
 JSR FMS CALL FMS
 LBNE FMSERR IF ERROR DETECTED
 LDB #7 GET IR CODE
 STB 0,X SET CODE
 JSR FMS CALL FMS
 LBNE FMSERR IF ERROR DETECTED
 LDD 21,X GET NUMBER OF SECTORS REMAINING
 JMP LB4F4 RETURN VALUE

DRIVE
ZCDE9 RMB 5 ROM $CDE9 - $CEA9
 LBHI DNERR
 STB DRIVNO
 RMB 1 RTS
ENT18B RMB 18
 LDX #LCE10
 RMB 5

LCE10 RMB 6
 LBEQ LBC33
 RMB 13
 LBCS LAFB1
 RMB 3
VCODXD  RMB 6
 LBNE VCODEX
 RMB 4
 LBEQ L9650
 RMB 5
 LBHI FCERR
 RMB 5

LCE4E RMB 8

FCODXD RMB 2  SPECIAL HANDLING FOR "POS"
 LBNE FCODEX
 RMB 17
 JSR GTFCB2
 RMB 16

LCE80 RMB 12

SAVEM  RMB 2 JSR <GETNXT
 BSR SAVEM4 GET NAME
 RMB 8
 LBCS FCERR
 RMB 12
 JSR SAVE1 OPEN FILE
ZCEAE RMB 7 ROM $CEAE - $CEB4
 STD 2,S SAVE LENGTH INSTEAD OF END
SAVEM0 TSTA
 BEQ SAVM00
 SUBD #$FF
 STD 2,S
 LDY #$00FF
 BRA SAVM01
SAVM00 TFR D,Y
 CLRA
 CLRB
 STD 2,S INDICATE WHEN DONE
SAVM01 LDA #$02 STX CODE
 BSR SAVEM3 WRITE IT
 LDD 4,S WRITE START ADDRESS
 TFR D,X
 BSR SAVEM2
 TFR Y,D WRITE LENGTH (1 BYTE)
 EXG A,B
 BSR SAVEM3
 ADDD 4,S + START ADDRESS
 STD 4,S = NEW START
SAVEM1
ZCEBF RMB 2 ROM $CEBF - $CEC7
 JSR OUTDC1
 RMB 4
 LDD 2,S LENGTH REMAINING
 BNE SAVEM0
 LDA #$16 CODE FOR XFER ADDR
 BSR SAVEM3
ZCED0 RMB 7 ROM $CED0 - $CEEB
SAVEM2 RMB 2
SAVEM3 JSR OUTDC1
 RMB 3

SAVEM4 LDX #BINTYP
 JMP GETNAM

LOADM RMB 4 
 LDD #$0200
 STD FILTYP FORCE BINARY
 JSR LOAD4 OPEN FOR READING

ZCEF6 RMB 12 ROM $CEF6 - $CF09
LOADM1 RMB 5

LOADM2 JSR INPU13 READ A CHARACTER
 CMP A #$02
 BEQ LOADMX
 CMP A #$16
 BNE LOADM2
LOADMX PSHS A SAVE IT
 BSR LOADM6 READ A WORD (ADDRESS)
ZCF12  RMB 8 ROM $CF12 - $CF1D
 CMPA #$16
 LBEQ LA42D
 PSHS X
 CLRB FORCE HIGH BYTE OF COUNT TO ZERO
 BSR LOADM7
 TFR D,Y GET COUNT
 PULS X
LOADM3
ZCF1E JSR INPDC1 ROM $CF1E - $CF3E
 RMB 4
 JMP IEERR
LOADM4 RMB 6
 JMP IOERRD
LOADM5  RMB 4
 BRA LOADM2
LOADM6 RMB 2
LOADM7 JSR INPU13
 RMB 3

RENAME  BSR RENAM2 GET FROM NAME
 LDX #SYSFCB
 LBSR SETFC2 SET UP FILE SPEC IN FCB
 BSR RENAM1 SKIP "TO" AND GET 2ND NAME
 JSR LA5C7 FINISH STATEMENT
 LDA SYSFCB+3
 CMPA <DCDRV MAKE SURE ITS THE SAME DRIVE
 LBNE FCERR
ZCF63 RMB 3 ROM $CF63 - $CF6D
 LDU #SYSFCB+53
 RMB 2 LDB #11 MOVE NEW NAME TO SCRATCH 
 RMB 3 JSR MOVE
 LDX #SYSFCB
 LDA #13 FMS RENAME CALL
 STA 0,X
 JSR FMS 
 LBNE FMSERR
 RTS
RENAM1 
ZCF75  RMB 2 ROM $CF75 - $CF7C LDB #$A5
 RMB 3 JSR LB26F
RENAM2 JMP GETNA0


WRITE 
ZCF8A LBEQ LB958 ROM $CF8A - $D0CE
 RMB $11
 LBEQ LB958
 RMB $15
 LBEQ LB958
 RMB $24

FIELD JSR RANCHK
 RMB $42
RSET RMB 1
LSET RMB $5A

FILES RMB $1B
 LBHI FCERR
 RMB $11
FILES2 JSR CLSALL
 RMB 9
 BCS FILES6
 RMB 2
FILES3 ADDD #FCBSIZ
 BCS FILES6
 RMB 8
 BEQ FILES6
FILE31 BITA #$01 INSURE 512 BYTE BOUNDARY
 BEQ FILES4
 INCA
 BEQ FILES6
ZD0CF EQU * ROM $D0CF - $D174
FILES4 RMB $4C
FILES6 RMB $1E
 LEAX FCBSIZ,X
 RMB 9
UNLOAD  RMB 4
 JSR GETFCB
 RMB 2
 LDA FCBDRV,X
 RMB 6
 JSR CLOSE2
 RMB 8

UNLOA3 LDB DRIVNO
 RMB 9
 LBHI DNERR
 RMB 3

CLRFCB 
ZD1E5 RMB $2A ROM $D1E5-$D20E

DSKIN
ZD3FF RMB 12 ROM $D3FF - $D4A0
 JSR DSKOU2 READ THE SECTOR
 LDU #SYSFCB+64+$80
 RMB 4
 LDU #SYSFCB+64 FILL FIRST STRING
 RMB $2D
 CMPB #$27 ALLOW FOR 40 TRACKS
 RMB $2D
DSKOUT RMB $12
 LDX #SYSFCB+64
 RMB 7
 LDU #SYSFCB+64+$80
 RMB 7
 LDU #SYSFCB+64
 RMB 4

DSKOU2 ADDB #7 FOR FLEX CODES
 LDX #SYSFCB
 STB 0,X
 LDB DCDRV
 STB 3,X
 LDD DCTRK
 STD 30,X
 JSR FMS
 LBNE FMSERR
 RTS

IOERRD
ZD616  RMB 2 ROM $D616 - $D61A
LD618  RMB 3

VERIFY
ZD65B RMB 8 ROM $D65B - $D66B
 LBNE SNERR
VERIF1 STB VERFLG
 RMB 2
NMID EQU *
NMIRTI
ZD7BB RMB 1 ROM $D7BB - $D7CE
IRQD RMB 11
 BEQ IRQD1
 RMB 4
 BNE IRQD1
 JSR MTROFF
IRQD1
ZD7DA RMB 3 ROM $D7DA - $D7DC
 
FMS PSHS B,U,Y
    LDY #$D406 FMS ENTRY POINT
    BRA FIXUP

RPTERR PSHS B,U,Y
    LDY #$CD3F RPTERR ENTRY POINT
    

FIXUP 
    LDB $CD4E
    LDU $CD4E+1
    PSHS B,U
    LDU #$1A04 ORCC #$04 (SET Z BIT)
    LDB #$39  RTS
    STU $CD4E
    STB $CD4E+2  DUMMY OUT STAT CODE
    LDB $FF01
    PSHS B
    ANDB #$FE SHUTDOWN ALL IRQ'S
    STB $FF01
    LDB $FF03
    PSHS B
    ANDB #$FE
    STB $FF03
    ORCC #$10
    LDU #$C07D
    EXG S,U USE FLEX'S STACK AREA
    JSR 0,Y GO TO ROUTINE
    EXG S,U GET STACK BACK
    TFR CC,DP HOLD CONDITION CODE
    PULS B
    STB $FF03
    PULS B 
    STB $FF01
    LDB #120
    STB MTRTIM
    PULS B,U
    STB $CD4E
    STU $CD4E+1 RESTORE STAT ROUTINE
    CLRB CLEAR DP REG
    EXG B,DP
    AND B #$EF ENABEL INTERRUPTS
    TFR B,CC
    PULS B,U,Y,PC RETURN

 END
